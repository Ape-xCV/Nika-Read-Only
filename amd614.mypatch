--- a/arch/x86/kvm/cpuid.c	2025-03-24 14:02:41.000000000 +0000
+++ b/arch/x86/kvm/cpuid.c	2025-10-19 12:36:18.918837832 +0100
@@ -2030,6 +2030,8 @@
 }
 EXPORT_SYMBOL_GPL(kvm_cpuid);
 
+bool spoof_cpuid = false;
+
 int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
 {
 	u32 eax, ebx, ecx, edx;
@@ -2038,8 +2040,23 @@
 		return 1;
 
 	eax = kvm_rax_read(vcpu);
+	u32 function = eax;
 	ecx = kvm_rcx_read(vcpu);
 	kvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);
+	if (function == 0) {
+		if (!spoof_cpuid) {
+			if (rdtsc() > 725760000000)  // Intel® Core™ processors >300 seconds
+				spoof_cpuid = true;
+		}
+		if (spoof_cpuid) {
+//			ebx = 0x68747541;  // 'htuA'
+//			ecx = 0x444D4163;  // 'DMAc'
+//			edx = 0x69746E65;  // 'itne'
+			ebx = 0x756E6547;  // 'uneG'
+			ecx = 0x6C65746E;  // 'letn'
+			edx = 0x49656E69;  // 'Ieni'
+		}
+	}
 	kvm_rax_write(vcpu, eax);
 	kvm_rbx_write(vcpu, ebx);
 	kvm_rcx_write(vcpu, ecx);
--- a/arch/x86/kvm/x86.c	2025-06-10 12:15:58.000000000 +0100
+++ b/arch/x86/kvm/x86.c	2025-10-12 21:32:13.556796055 +0100
@@ -4236,17 +4236,23 @@
 		 * return L1's TSC value to ensure backwards-compatible
 		 * behavior for migration.
 		 */
-		u64 offset, ratio;
-
-		if (msr_info->host_initiated) {
-			offset = vcpu->arch.l1_tsc_offset;
-			ratio = vcpu->arch.l1_tsc_scaling_ratio;
-		} else {
-			offset = vcpu->arch.tsc_offset;
-			ratio = vcpu->arch.tsc_scaling_ratio;
-		}
-
-		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;
+//		u64 offset, ratio;  // NIKA removed
+		u64 rdtsc_read;  // NIKA added
+		u64 total_exit_time;  // NIKA added
+
+//		if (msr_info->host_initiated) {  // NIKA removed
+//			offset = vcpu->arch.l1_tsc_offset;  // NIKA removed
+//			ratio = vcpu->arch.l1_tsc_scaling_ratio;  // NIKA removed
+//		} else {  // NIKA removed
+//			offset = vcpu->arch.tsc_offset;  // NIKA removed
+//			ratio = vcpu->arch.tsc_scaling_ratio;  // NIKA removed
+//		}  // NIKA removed
+		rdtsc_read = rdtsc();  // NIKA added
+		total_exit_time = (rdtsc_read - vcpu->last_exit_start) + vcpu->total_exit_time;  // NIKA added
+
+//		msr_info->data = kvm_scale_tsc(rdtsc(), ratio) + offset;  // NIKA removed
+		msr_info->data = rdtsc_read - total_exit_time;  // NIKA added
+		vcpu->run->exit_reason = 1337;  // NIKA added
 		break;
 	}
 	case MSR_IA32_CR_PAT:
@@ -10701,7 +10707,8 @@
  * exiting to the userspace.  Otherwise, the value will be returned to the
  * userspace.
  */
-static int vcpu_enter_guest(struct kvm_vcpu *vcpu)
+//static int vcpu_enter_guest(struct kvm_vcpu *vcpu)  // NIKA removed
+static int vcpu_enter_guest_real(struct kvm_vcpu *vcpu)  // NIKA added
 {
 	int r;
 	bool req_int_win =
@@ -11111,6 +11118,20 @@
 	return r;
 }
 
+static int vcpu_enter_guest(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	vcpu->last_exit_start = rdtsc();
+	int result = vcpu_enter_guest_real(vcpu);
+
+	if (vcpu->run->exit_reason == 1337)
+	{
+		u64 rdtsc_diff = rdtsc() - vcpu->last_exit_start;
+		vcpu->total_exit_time += rdtsc_diff;
+	}
+
+	return result;
+}  // NIKA end
+
 static bool kvm_vcpu_running(struct kvm_vcpu *vcpu)
 {
 	return (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&
--- a/arch/x86/kvm/svm/svm.c	2025-06-10 12:15:58.000000000 +0100
+++ b/arch/x86/kvm/svm/svm.c	2025-10-12 21:33:31.456537686 +0100
@@ -1291,6 +1291,7 @@
 	svm_set_intercept(svm, INTERCEPT_XSETBV);
 	svm_set_intercept(svm, INTERCEPT_RDPRU);
 	svm_set_intercept(svm, INTERCEPT_RSM);
+	svm_set_intercept(svm, INTERCEPT_RDTSC);  // NIKA added
 
 	if (!kvm_mwait_in_guest(vcpu->kvm)) {
 		svm_set_intercept(svm, INTERCEPT_MONITOR);
@@ -3300,6 +3301,73 @@
 	return kvm_handle_invpcid(vcpu, type, gva);
 }
 
+static int cpuid_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	vcpu->run->exit_reason = 1337;
+	return kvm_emulate_cpuid(vcpu);
+}  // NIKA end
+
+static int invd_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	vcpu->run->exit_reason = 1337;
+	return kvm_emulate_invd(vcpu);
+}  // NIKA end
+
+static int wbinvd_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	vcpu->run->exit_reason = 1337;
+	return kvm_emulate_wbinvd(vcpu);
+}  // NIKA end
+
+static int xsetbv_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	vcpu->run->exit_reason = 1337;
+	return kvm_emulate_xsetbv(vcpu);
+}  // NIKA end
+
+static int rdtsc_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	u64 rdtsc_read;
+	u64 total_exit_time;
+	u64 data;
+
+	rdtsc_read = rdtsc();
+	total_exit_time = (rdtsc_read - vcpu->last_exit_start) + vcpu->total_exit_time;
+	data = rdtsc_read - total_exit_time;
+
+	vcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;
+	vcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;
+	vcpu->run->exit_reason = 1337;
+	return svm_skip_emulated_instruction(vcpu);
+}  // NIKA end
+
+static int rdtscp_interception(struct kvm_vcpu *vcpu)  // NIKA begin
+{
+	static u64 rdtsc_last;
+	static u64 rdtsc_prev;
+	static u64 rdtsc_read;
+	static u64 data;
+
+	rdtsc_last = rdtsc_prev;
+	rdtsc_prev = rdtsc_read;
+	rdtsc_read = rdtsc();
+	u64 diff_last = rdtsc_prev - rdtsc_last;
+	u64 diff_prev = rdtsc_read - rdtsc_prev;
+
+	u64 total_exit_time = (rdtsc_read - vcpu->last_exit_start) + vcpu->total_exit_time;
+	u64 data_diff = (rdtsc_read - total_exit_time) - data;
+	if (rdtsc_last != 0 && diff_last < diff_prev)
+		data = rdtsc_read - total_exit_time;
+	else
+		data += data_diff / 10;
+
+	vcpu->arch.regs[VCPU_REGS_RAX] = data & -1u;
+	vcpu->arch.regs[VCPU_REGS_RDX] = (data >> 32) & -1u;
+	vcpu->arch.regs[VCPU_REGS_RCX] = smp_processor_id();
+	vcpu->run->exit_reason = 1337;
+	return svm_skip_emulated_instruction(vcpu);
+}  // NIKA end
+
 static int (*const svm_exit_handlers[])(struct kvm_vcpu *vcpu) = {
 	[SVM_EXIT_READ_CR0]			= cr_interception,
 	[SVM_EXIT_READ_CR3]			= cr_interception,
@@ -3338,9 +3406,11 @@
 	[SVM_EXIT_SMI]				= smi_interception,
 	[SVM_EXIT_VINTR]			= interrupt_window_interception,
 	[SVM_EXIT_RDPMC]			= kvm_emulate_rdpmc,
-	[SVM_EXIT_CPUID]			= kvm_emulate_cpuid,
+//	[SVM_EXIT_CPUID]			= kvm_emulate_cpuid,  // NIKA removed
+	[SVM_EXIT_CPUID]			= cpuid_interception,  // NIKA added
 	[SVM_EXIT_IRET]                         = iret_interception,
-	[SVM_EXIT_INVD]                         = kvm_emulate_invd,
+//	[SVM_EXIT_INVD]                         = kvm_emulate_invd,  // NIKA removed
+	[SVM_EXIT_INVD]				= invd_interception,  // NIKA added
 	[SVM_EXIT_PAUSE]			= pause_interception,
 	[SVM_EXIT_HLT]				= kvm_emulate_halt,
 	[SVM_EXIT_INVLPG]			= invlpg_interception,
@@ -3356,11 +3426,14 @@
 	[SVM_EXIT_STGI]				= stgi_interception,
 	[SVM_EXIT_CLGI]				= clgi_interception,
 	[SVM_EXIT_SKINIT]			= skinit_interception,
-	[SVM_EXIT_RDTSCP]			= kvm_handle_invalid_op,
-	[SVM_EXIT_WBINVD]                       = kvm_emulate_wbinvd,
+//	[SVM_EXIT_RDTSCP]			= kvm_handle_invalid_op,  // NIKA removed
+	[SVM_EXIT_RDTSCP]			= rdtscp_interception,  // NIKA added
+//	[SVM_EXIT_WBINVD]                       = kvm_emulate_wbinvd,  // NIKA removed
+	[SVM_EXIT_WBINVD]			= wbinvd_interception,  // NIKA added
 	[SVM_EXIT_MONITOR]			= kvm_emulate_monitor,
 	[SVM_EXIT_MWAIT]			= kvm_emulate_mwait,
-	[SVM_EXIT_XSETBV]			= kvm_emulate_xsetbv,
+//	[SVM_EXIT_XSETBV]			= kvm_emulate_xsetbv,  // NIKA removed
+	[SVM_EXIT_XSETBV]			= xsetbv_interception,  // NIKA added
 	[SVM_EXIT_RDPRU]			= kvm_handle_invalid_op,
 	[SVM_EXIT_EFER_WRITE_TRAP]		= efer_trap,
 	[SVM_EXIT_CR0_WRITE_TRAP]		= cr_trap,
@@ -3371,6 +3444,7 @@
 	[SVM_EXIT_RSM]                          = rsm_interception,
 	[SVM_EXIT_AVIC_INCOMPLETE_IPI]		= avic_incomplete_ipi_interception,
 	[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]	= avic_unaccelerated_access_interception,
+	[SVM_EXIT_RDTSC]			= rdtsc_interception,  // NIKA added
 #ifdef CONFIG_KVM_AMD_SEV
 	[SVM_EXIT_VMGEXIT]			= sev_handle_vmgexit,
 #endif
--- a/include/linux/kvm_host.h	2025-06-10 12:15:58.000000000 +0100
+++ b/include/linux/kvm_host.h	2025-10-12 21:15:30.517270374 +0100
@@ -348,6 +348,9 @@
 	unsigned int halt_poll_ns;
 	bool valid_wakeup;
 
+	u64 last_exit_start;  // NIKA added
+	u64 total_exit_time;  // NIKA added
+
 #ifdef CONFIG_HAS_IOMEM
 	int mmio_needed;
 	int mmio_read_completed;
